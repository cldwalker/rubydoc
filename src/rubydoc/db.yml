- ruby: Open3.capture3
  clj: clojure.java.shell/sh
- ruby: Kernel#system
  clj: clojure.java.shell/sh
  similar: true
  desc: sh executes commands but unlike system, stdout is captured as a string.
- ruby: Kernel#exit
  clj: System/exit
- ruby: Kernel#require
  clj: clojure.core/require
  desc: They are mostly the same though the clojure version has useful :reload and :reload-all flags.
- ruby: Kernel#load
  clj: clojure.core/load-file
- ruby: __FILE__
  clj: "*file*"
  desc: "The ruby value is relative to the current directory and can just be expanded. The clojure value is relative to a classpath directory (not the current directory) and needs to be expanded with: (ClassLoader/getSystemResource *file*)"
- ruby: Kernel#puts
  clj: clojure.core/println
- ruby: Kernel#print
  clj: clojure.core/print
- ruby: Kernel#pp
  clj: clojure.pprint/pprint
  desc: The ruby meth comes from requiring 'pp', a file in stdlib.
- ruby: Kernel#sleep
  clj: Thread/sleep
- ruby: Kernel#at_exit
  clj: (.addShutdownHook (Runtime/getRuntime) fn-wrapped-in-a-thread)
  similar: true
  desc: Whereas at_exits are run in the reverse order defined, multiple ShutdownHooks are run concurrently in an unspecified order.
- ruby: Object#send
  clj: "@#'namespace/meth"
  similar: true
  desc: |
    To call private methods as send can, place the deref-ed Var in the function place i.e. (@#'meth arg1). To dynamically call a ruby variable as send can, convert your clojure symbol to a Var and deref. For example, if you had the function "println" as a string, convert the string into a function and execute it: (@(resolve (symbol "println")) "WOOT").
- ruby: Object#tap
  clj: clojure.core/doto
  desc: |
    Both tap and doto take an object, act on it with a block/function and then pass on the original object. To compare, given this ruby example "10.tap {|n| puts n } + 5", the clojure equivalent is "(-> 10 (doto println) (+ 5))".
- ruby: Class#new
  clj: new
  desc: Given a ruby example "Klass.new(arg)", the clojure equivalent is "(new Klass arg) or (Klass. arg)".
- ruby: Object#instance_of?
  clj: clojure.core/instance?
- ruby: Kernel#raise
  clj: throw
- ruby: Object#respond_to?
  clj: clojure.core/ns-resolve
  similar: true
  desc: Whereas respond_to? indicates if an object can call a method, ns-resolve indicates if a namespace can use a Var/Class. ns-resolve is different in that it doesn't return a boolean or report only about functions. See clojure.core/resolve for assuming current namespace.
- ruby: Symbol#to_s
  clj: clojure.core/name
  desc: Use when wanting to stringify a clojure keyword aka ruby symbol.
- ruby: Exception#backtrace
  clj: clojure.repl/pst
  similar: true
  desc: If in a repl, pst will print the given or last exception's stacktrace. If in a program, use (.getStackTrace Exception). To get a useful stacktrace array, more work is required.
- ruby: Exception#message
  clj: (.getMessage exception)
- ruby: Module#include
  clj: clojure.core/refer
  desc: Whereas include brings in methods into a module via a class hierarchy, refer brings in vars via mappings. refer has finer-grained control allowing you to rename or selectively include/exclude some vars. See clojure.core/import for importing Java classes into a namespace (no ruby equivalent).
- ruby: Module#ancestors
  clj: clojure.core/supers
  desc: Note that supers is for java classes. See clojure.core/ancestors for tracing tag or class ancestry.
- ruby: IO.open
  clj: clojure.core/with-open
  desc: with-open is more general as it takes multiple objects to read and close and is open to any java object that has .close defined.
- ruby: IO.read and Kernel#open from open-uri stdlib
  clj: clojure.core/slurp
  desc: slurp is a generalize read, reading anything java.io.Reader can read which includes files and urls.
- ruby: IO.foreach
  clj: line-seq
- ruby: File.directory?
  clj: (.isDirectory (clojure.java.io/file some_file))
- ruby: Dir.glob
  clj: '(defn glob [dir regex] (->> (clojure.java.io/file dir) (file-seq) (map str) (filter #(re-find regex %))))'
  similar: true
  desc: This is a simpler version of glob that fully descends a directory and matches files for the given regex.
- ruby: ENV
  clj: (System/getenv)
  desc: To get specific env values, pass the env name to getenv.
- ruby: RbConfig::CONFIG
  clj: (System/getProperties)
  desc: A comprehensive map of system and language information.
- ruby: Dir.home
  clj: (System/getProperty "user.home")
- ruby: "$: or $LOAD_PATH"
  clj: (seq (.getURLs (ClassLoader/getSystemClassLoader)))
  desc: These are the loaded loadpaths/classpaths available in your runtime. While in ruby you can just add to this array, clojure will be disallowing this soon - see deprecated clojure.core/add-classpath.
- ruby: $RUBYLIB
  clj: $CLASSPATH
  desc: These environment variables can be manipulated before invoking a program to modify its loadpath/classpath.
- ruby: STDIN or $stdin
  clj: "*in*"
- ruby: STDOUT or $stdout
  clj: "*out*"
- ruby: STDERR or $stderr
  clj: "*err*"
- ruby: _
  clj: "*1"
  desc: "These give back the returned value from the last statement in a repl. Clojure also has *2 and *3 for 2nd and 3rd to last values."
- ruby: $!
  clj: "*e"
  similar: true
  desc: While ruby's is available to any program, the clojure one is only available in the repl.
