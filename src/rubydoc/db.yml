- ruby: Open3.capture3
  clj: clojure.java.shell/sh
- ruby: Kernel#system
  clj: clojure.java.shell/sh
  similar: true
  desc: sh executes commands but unlike system, stdout is captured as a string.
- ruby: Kernel#exit
  clj: System/exit
- ruby: Kernel#require
  clj: clojure.core/require
  desc: They are mostly the same though the clojure version has useful :reload and :reload-all flags.
- ruby: Kernel#load
  clj: clojure.core/load-file
- ruby: __FILE__
  clj: "*file*"
  desc: "The ruby value is relative to the current directory and can just be expanded. The clojure value is relative to a classpath directory (not the current directory) and needs to be expanded with: (ClassLoader/getSystemResource *file*)"
- ruby: Kernel#puts
  clj: clojure.core/println
- ruby: Kernel#print
  clj: clojure.core/print
- ruby: Kernel#pp
  clj: clojure.pprint/pprint
  desc: The ruby meth comes from requiring 'pp', a file in stdlib.
- ruby: Kernel#sleep
  clj: Thread/sleep
- ruby: Kernel#at_exit
  clj: (.addShutdownHook (Runtime/getRuntime) fn-wrapped-in-a-thread)
  similar: true
  desc: Whereas at_exits are run in the reverse order defined, multiple ShutdownHooks are run concurrently in an unspecified order.
- ruby: Object#send
  clj: "@#'namespace/meth"
  similar: true
  desc: |
    To call private methods as send can, place the deref-ed Var in the function place i.e. (@#'meth arg1). To dynamically call a ruby variable as send can, convert your clojure symbol to a Var and deref. For example, if you had the function "println" as a string, convert the string into a function and execute it: (@(resolve (symbol "println")) "WOOT").
- ruby: Object#tap
  clj: clojure.core/doto
  desc: |
    Both tap and doto take an object, act on it with a block/function and then pass on the original object. To compare, given this ruby example "10.tap {|n| puts n } + 5", the clojure equivalent is "(-> 10 (doto println) (+ 5))".
- ruby: Class#new
  clj: new
  desc: Given a ruby example "Klass.new(arg)", the clojure equivalent is "(new Klass arg) or (Klass. arg)".
- ruby: Object#instance_of?
  clj: clojure.core/instance?
- ruby: Kernel#raise
  clj: throw
- ruby: Object#respond_to?
  clj: clojure.core/ns-resolve
  similar: true
  desc: Whereas respond_to? indicates if an object can call a method, ns-resolve indicates if a namespace can use a Var/Class. ns-resolve is different in that it doesn't return a boolean or report only about functions. See clojure.core/resolve for assuming current namespace.
- ruby: Symbol#to_s
  clj: clojure.core/name
  desc: Use when wanting to stringify a clojure keyword aka ruby symbol.
- ruby: Exception#backtrace
  clj: clojure.repl/pst
  similar: true
  desc: If in a repl, pst will print the given or last exception's stacktrace. If in a program, use (.getStackTrace Exception). To get a useful stacktrace array, more work is required.
- ruby: Exception#message
  clj: (.getMessage exception)
- ruby: Module#include
  clj: clojure.core/refer
  desc: Whereas include brings in methods into a module via a class hierarchy, refer brings in vars via mappings. refer has finer-grained control allowing you to rename or selectively include/exclude some vars. See clojure.core/import for importing Java classes into a namespace (no ruby equivalent).
- ruby: Module#ancestors
  clj: clojure.core/supers
  desc: Note that supers is for java classes. See clojure.core/ancestors for tracing tag or class ancestry.
- ruby: IO.open
  clj: clojure.core/with-open
  desc: with-open is more general as it takes multiple objects to read and close and is open to any java object that has .close defined.
- ruby: IO.read and Kernel#open from open-uri stdlib
  clj: clojure.core/slurp
  desc: slurp is a generalize read, reading anything java.io.Reader can read which includes files and urls.
- ruby: IO.foreach
  clj: line-seq
- ruby: File.directory?
  clj: (.isDirectory (clojure.java.io/file some_file))
- ruby: Dir.glob
  clj: '(defn glob [dir regex] (->> (clojure.java.io/file dir) (file-seq) (map str) (filter #(re-find regex %))))'
  similar: true
  desc: This is a simpler version of glob that fully descends a directory and matches files for the given regex.
- ruby: ENV
  clj: System/getenv
  desc: To get specific env values, pass the env name to getenv.
- ruby: RbConfig::CONFIG
  clj: System/getProperties
  desc: A comprehensive map of system and language information.
- ruby: Dir.home
  clj: (System/getProperty "user.home")
- ruby: "$: or $LOAD_PATH"
  clj: (seq (.getURLs (ClassLoader/getSystemClassLoader)))
  desc: These are the loaded loadpaths/classpaths available in your runtime. While in ruby you can just add to this array, clojure will be disallowing this soon - see deprecated clojure.core/add-classpath.
- ruby: $RUBYLIB
  clj: $CLASSPATH
  desc: These environment variables can be manipulated before invoking a program to modify its loadpath/classpath.
- ruby: STDIN or $stdin
  clj: "*in*"
- ruby: STDOUT or $stdout
  clj: "*out*"
- ruby: STDERR or $stderr
  clj: "*err*"
- ruby: _
  clj: "*1"
  desc: "These give back the returned value from the last statement in a repl. Clojure also has *2 and *3 for 2nd and 3rd to last values."
- ruby: $!
  clj: "*e"
  similar: true
  desc: While ruby's is available to any program, the clojure one is only available in the repl.
- ruby: String#to_i
  clj: (Integer. "string")
- ruby: Integer#times
  clj: clojure.core/dotimes
  desc: Given the ruby example "5.times {|n| }", the clojure equivalent would be "(dotimes [n 5] )"
- ruby: Array#new
  clj: clojure.core/repeat
  desc: Given the ruby example which generates a vector of 5 3's - "Array.new(5, 3)", the clojure equivalent would be "(repeat 5 3)".
- ruby: Benchmark.measure from benchmark stdlib
  clj: clojure.core/time
  desc: Prints time taken for given code to run.
- ruby: Struct#new
  clj: clojure.core/defstruct
  desc: Given this ruby example "Person = Struct.new(:name, :age); Person.new('Bo', 8)", the clojure equivalent would be '(defstruct person :name :age) (struct person "Bo" 8)'.
- ruby: ActiveSupport/Memoizable#memoize from activesupport gem
  clj: memoize
  desc: Memoizes a function based on arguments.
- ruby: ObjectSpace.each_object(Module).to_a - ObjectSpace.each_object(Class).to_a
  clj: clojure.core/all-ns
  similar: true
  desc: If you think of ruby's modules as clojure namespaces, these two are equivalent. For the ruby example, Class objects were subtracted from Module objects since a Class is a Module.
- ruby: Proc#curry
  clj: clojure.core/partial
  desc: |
    Generates a function given a function. Given the ruby example "proc {|x,y,z| p x,y,z }.curry[2][1,3]", the clojure equivalent is "((partial #(prn %1 %2 %3) 2) 1 3)". Note that the ruby version doesn't let you populate default args until you call #[] while the clojure one requires at least arg to populate the new function.
- ruby: Proc#source_location or Method#source_location or UnboundMethod#source_location
  clj: clojure.repl/source
  similar: true
  desc: Whereas the clojure version prints the given function for you, the ruby one only tells you where it starts.
- ruby: Proc#parameters or Method#parameters or UnboundMethod#parameters
  clj: "(first ((meta #'fn-name) :arglists))"
  desc: Returns arguments for given method/function. The ruby version an array of arrays with each array pair indicating if the argument is required, optional or a splatted arg - respectively :req, :opt, :rest.
- ruby: Array#slice(1..-1)
  clj: clojure.core/rest
- ruby: Hash#[] or Hash#fetch
  clj: clojure.core/get
  desc: Like fetch, get can take a default value if the key doesn't exist for the map/hash. Unlike fetch, get doesn't fail if a given key isn't found.
- ruby: Hash#[]=
  clj: clojure.core/assoc
  desc: assoc can take more than 2 arguments to set additional key/pairs
- ruby: Hash#merge
  clj: clojure.core/merge
  desc: The clojure version can merge multiple maps. The ruby version takes a block to resolve merge conflicts while clojure requires clojure.core/merge-with to do that.
- ruby: Enumerable#count
  clj: clojure.core/count
- ruby: Hash#key?
  clj: clojure.core/contains
- ruby: Hash#delete
  clj: clojure.core/dissoc
  desc: dissoc can also delete multiple keys.
- ruby: Enumerable#reduce
  clj: clojure.core/reduce
- ruby: Enumerable#map
  clj: clojure.core/map
  desc: The clojure version can take multiple collections and pass as them additional args while the ruby version can only take one array.
- ruby: Hash.[]
  clj: clojure.core/hash-map
  desc: Used often to convert a vec/array to a map/hash. For the ruby example of "Hash[*[1,2,3,4]]", the clojure equivalent is "(apply hash-map [1 2 3 4])".
- ruby: Hash#invert
  clj: clojure.set/map-invert
- ruby: Array#uniq
  clj: clojure.core/distinct
- ruby: String#slice(regexp)
  clj: clojure.core/re-find
  desc: 'Returns a string if there is match or nil. For the given ruby version "okdok"[/ok/], the clojure equivalent is (re-find #"ok" "okdok").'
- ruby: String#split
  clj: clojure.string/split
  desc: The ruby version can split on string or regexp while the clojure version only does regexp.
- ruby: 'String#+ or String#<<'
  clj: clojure.core/str
  desc: |
    Clojure version handles multiple arguments. While ruby version doesnt offer this, it does have interpolation "#{one} and #{two}" vs (str one " and " two).
- ruby: String#% or Kernel#sprintf
  clj: clojure.core/format
- ruby: String#sub
  clj: clojure.string/replace-first
- ruby: String#gsub
  clj: clojure.string/replace
- ruby: String#slice(offset, count)
  clj: (.substring "string" offset count)
- ruby: String#scan
  clj: clojure.core/re-seq
  desc: Returns a list of all matches a regexp has against a string.
- ruby: Array#join
  clj: clojure.string/join
  desc: Join an array/vec by a given string.
- ruby: String#upcase
  clj: clojure.string/upper-case
- ruby: String#downcase
  clj: clojure.string/lower-case
- ruby: String#lstrip
  clj: clojure.string/triml
- ruby: String#strip
  clj: clojure.string/trim
- ruby: String#rstrip
  clj: clojure.string/trimr
- ruby: String#split
  clj: clojure.string/split-lines
- ruby: String#reverse
  clj: clojure.string/reverse
